{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\nimport { PitchCorrectionQuality } from \"./AV.types\";\nexport var _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 500;\nexport var _DEFAULT_INITIAL_PLAYBACK_STATUS = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false\n};\nexport function getNativeSourceFromSource(source) {\n  var uri = null;\n  var overridingExtension = null;\n  var headers;\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension: overridingExtension,\n      headers: headers\n    };\n  }\n\n  var asset = _getAssetFromPlaybackSource(source);\n\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (source != null && typeof source !== 'number' && 'uri' in source && typeof source.uri === 'string') {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (source != null && typeof source !== 'number' && 'overrideFileExtensionAndroid' in source && typeof source.overrideFileExtensionAndroid === 'string') {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (source != null && typeof source !== 'number' && 'headers' in source && typeof source.headers === 'object') {\n    headers = source.headers;\n  }\n\n  return {\n    uri: uri,\n    overridingExtension: overridingExtension,\n    headers: headers\n  };\n}\n\nfunction _getAssetFromPlaybackSource(source) {\n  if (source == null) {\n    return null;\n  }\n\n  var asset = null;\n\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n\n  return asset;\n}\n\nexport function assertStatusValuesInBounds(status) {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\nexport function getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst) {\n  var fullInitialStatus, asset, nativeSource;\n  return _regeneratorRuntime.async(function getNativeSourceAndFullInitialStatusForLoadAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          fullInitialStatus = initialStatus == null ? _DEFAULT_INITIAL_PLAYBACK_STATUS : _objectSpread(_objectSpread({}, _DEFAULT_INITIAL_PLAYBACK_STATUS), initialStatus);\n          assertStatusValuesInBounds(fullInitialStatus);\n\n          if (!(typeof source === 'string' && Platform.OS === 'web')) {\n            _context.next = 4;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            nativeSource: {\n              uri: source,\n              overridingExtension: null\n            },\n            fullInitialStatus: fullInitialStatus\n          });\n\n        case 4:\n          asset = _getAssetFromPlaybackSource(source);\n\n          if (!(downloadFirst && asset)) {\n            _context.next = 8;\n            break;\n          }\n\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(asset.downloadAsync());\n\n        case 8:\n          nativeSource = getNativeSourceFromSource(source);\n\n          if (!(nativeSource === null)) {\n            _context.next = 11;\n            break;\n          }\n\n          throw new Error(\"Cannot load an AV asset from a null playback source\");\n\n        case 11:\n          return _context.abrupt(\"return\", {\n            nativeSource: nativeSource,\n            fullInitialStatus: fullInitialStatus\n          });\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getUnloadedStatus() {\n  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return _objectSpread({\n    isLoaded: false\n  }, error ? {\n    error: error\n  } : null);\n}\nexport var PlaybackMixin = {\n  playAsync: function playAsync() {\n    var _this = this;\n\n    return function _callee() {\n      return _regeneratorRuntime.async(function _callee$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", _this.setStatusAsync({\n                shouldPlay: true\n              }));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  playFromPositionAsync: function playFromPositionAsync(positionMillis) {\n    var _arguments = arguments,\n        _this2 = this;\n\n    return function _callee2() {\n      var tolerances;\n      return _regeneratorRuntime.async(function _callee2$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              tolerances = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n              return _context3.abrupt(\"return\", _this2.setStatusAsync({\n                positionMillis: positionMillis,\n                shouldPlay: true,\n                seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n                seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n              }));\n\n            case 2:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  pauseAsync: function pauseAsync() {\n    var _this3 = this;\n\n    return function _callee3() {\n      return _regeneratorRuntime.async(function _callee3$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", _this3.setStatusAsync({\n                shouldPlay: false\n              }));\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  stopAsync: function stopAsync() {\n    var _this4 = this;\n\n    return function _callee4() {\n      return _regeneratorRuntime.async(function _callee4$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", _this4.setStatusAsync({\n                positionMillis: 0,\n                shouldPlay: false\n              }));\n\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setPositionAsync: function setPositionAsync(positionMillis) {\n    var _arguments2 = arguments,\n        _this5 = this;\n\n    return function _callee5() {\n      var tolerances;\n      return _regeneratorRuntime.async(function _callee5$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              tolerances = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n              return _context6.abrupt(\"return\", _this5.setStatusAsync({\n                positionMillis: positionMillis,\n                seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n                seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n              }));\n\n            case 2:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setRateAsync: function setRateAsync(rate) {\n    var _arguments3 = arguments,\n        _this6 = this;\n\n    return function _callee6() {\n      var shouldCorrectPitch, pitchCorrectionQuality;\n      return _regeneratorRuntime.async(function _callee6$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              shouldCorrectPitch = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : false;\n              pitchCorrectionQuality = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : PitchCorrectionQuality.Low;\n              return _context7.abrupt(\"return\", _this6.setStatusAsync({\n                rate: rate,\n                shouldCorrectPitch: shouldCorrectPitch,\n                pitchCorrectionQuality: pitchCorrectionQuality\n              }));\n\n            case 3:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setVolumeAsync: function setVolumeAsync(volume) {\n    var _this7 = this;\n\n    return function _callee7() {\n      return _regeneratorRuntime.async(function _callee7$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              return _context8.abrupt(\"return\", _this7.setStatusAsync({\n                volume: volume\n              }));\n\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setIsMutedAsync: function setIsMutedAsync(isMuted) {\n    var _this8 = this;\n\n    return function _callee8() {\n      return _regeneratorRuntime.async(function _callee8$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", _this8.setStatusAsync({\n                isMuted: isMuted\n              }));\n\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setIsLoopingAsync: function setIsLoopingAsync(isLooping) {\n    var _this9 = this;\n\n    return function _callee9() {\n      return _regeneratorRuntime.async(function _callee9$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", _this9.setStatusAsync({\n                isLooping: isLooping\n              }));\n\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setProgressUpdateIntervalAsync: function setProgressUpdateIntervalAsync(progressUpdateIntervalMillis) {\n    var _this10 = this;\n\n    return function _callee10() {\n      return _regeneratorRuntime.async(function _callee10$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              return _context11.abrupt(\"return\", _this10.setStatusAsync({\n                progressUpdateIntervalMillis: progressUpdateIntervalMillis\n              }));\n\n            case 1:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  }\n};\nexport * from \"./AV.types\";","map":{"version":3,"mappings":"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","names":["Asset","Platform","PitchCorrectionQuality","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","_DEFAULT_INITIAL_PLAYBACK_STATUS","positionMillis","progressUpdateIntervalMillis","shouldPlay","rate","shouldCorrectPitch","volume","isMuted","isLooping","getNativeSourceFromSource","source","uri","overridingExtension","headers","OS","asset","_getAssetFromPlaybackSource","localUri","overrideFileExtensionAndroid","fromModule","assertStatusValuesInBounds","status","RangeError","getNativeSourceAndFullInitialStatusForLoadAsync","initialStatus","downloadFirst","fullInitialStatus","nativeSource","downloadAsync","Error","getUnloadedStatus","error","isLoaded","PlaybackMixin","playAsync","setStatusAsync","playFromPositionAsync","tolerances","seekMillisToleranceAfter","toleranceMillisAfter","seekMillisToleranceBefore","toleranceMillisBefore","pauseAsync","stopAsync","setPositionAsync","setRateAsync","pitchCorrectionQuality","Low","setVolumeAsync","setIsMutedAsync","setIsLoopingAsync","setProgressUpdateIntervalAsync"],"sourceRoot":"","sources":["../src/AV.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false,\n};\n\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: { [fieldName: string]: string } | undefined;\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\n\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\nexport interface AV {\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\nexport interface Playback extends AV {\n  playAsync(): Promise<AVPlaybackStatus>;\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet,\n    downloadAsync: boolean\n  ): Promise<AVPlaybackStatus>;\n  unloadAsync(): Promise<AVPlaybackStatus>;\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ): Promise<AVPlaybackStatus>;\n  pauseAsync(): Promise<AVPlaybackStatus>;\n  stopAsync(): Promise<AVPlaybackStatus>;\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ): Promise<AVPlaybackStatus>;\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n  setVolumeAsync(volume: number): Promise<AVPlaybackStatus>;\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * A mixin that defines common playback methods for A/V classes so they implement the `Playback`\n * interface\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: { toleranceMillisBefore?: number; toleranceMillisAfter?: number } = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: { toleranceMillisBefore?: number; toleranceMillisAfter?: number } = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Low\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"]},"metadata":{},"sourceType":"module"}