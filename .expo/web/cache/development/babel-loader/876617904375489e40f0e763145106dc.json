{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { UnavailabilityError } from 'expo-modules-core';\nimport ExpoFaceDetector from \"./ExpoFaceDetector\";\nexport var FaceDetectorMode;\n\n(function (FaceDetectorMode) {\n  FaceDetectorMode[FaceDetectorMode[\"fast\"] = 1] = \"fast\";\n  FaceDetectorMode[FaceDetectorMode[\"accurate\"] = 2] = \"accurate\";\n})(FaceDetectorMode || (FaceDetectorMode = {}));\n\nexport var FaceDetectorLandmarks;\n\n(function (FaceDetectorLandmarks) {\n  FaceDetectorLandmarks[FaceDetectorLandmarks[\"all\"] = 1] = \"all\";\n  FaceDetectorLandmarks[FaceDetectorLandmarks[\"none\"] = 2] = \"none\";\n})(FaceDetectorLandmarks || (FaceDetectorLandmarks = {}));\n\nexport var FaceDetectorClassifications;\n\n(function (FaceDetectorClassifications) {\n  FaceDetectorClassifications[FaceDetectorClassifications[\"all\"] = 1] = \"all\";\n  FaceDetectorClassifications[FaceDetectorClassifications[\"none\"] = 2] = \"none\";\n})(FaceDetectorClassifications || (FaceDetectorClassifications = {}));\n\nexport function detectFacesAsync(uri) {\n  var options,\n      _args = arguments;\n  return _regeneratorRuntime.async(function detectFacesAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n          if (ExpoFaceDetector.detectFaces) {\n            _context.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-face-detector', 'detectFaces');\n\n        case 3:\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(ExpoFaceDetector.detectFaces(_objectSpread(_objectSpread({}, options), {}, {\n            uri: uri\n          })));\n\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"mappings":";;;;;;;AAAA,SAASA,mBAAT,QAAoC,mBAApC;AAEA,OAAOC,gBAAP;AAgHA,WAAYC,gBAAZ;;AAAA,WAAYA,gBAAZ,EAA4B;EAC1BA;EACAA;AACD,CAHD,EAAYA,gBAAgB,KAAhBA,gBAAgB,MAA5B;;AAMA,WAAYC,qBAAZ;;AAAA,WAAYA,qBAAZ,EAAiC;EAC/BA;EACAA;AACD,CAHD,EAAYA,qBAAqB,KAArBA,qBAAqB,MAAjC;;AAMA,WAAYC,2BAAZ;;AAAA,WAAYA,2BAAZ,EAAuC;EACrCA;EACAA;AACD,CAHD,EAAYA,2BAA2B,KAA3BA,2BAA2B,MAAvC;;AA4EA,OAAO,SAAeC,gBAAf,CACLC,GADK;EAAA;EAAA;EAAA;IAAA;MAAA;QAAA;UAELC,OAFK,2DAEuB,EAFvB;;UAAA,IAIAN,gBAAgB,CAACO,WAJjB;YAAA;YAAA;UAAA;;UAAA,MAKG,IAAIR,mBAAJ,CAAwB,oBAAxB,EAA8C,aAA9C,CALH;;QAAA;UAAA;UAAA,iCAOQC,gBAAgB,CAACO,WAAjB,iCAAkCD,OAAlC;YAA2CD,GAAG,EAAHA;UAA3C,GAPR;;QAAA;UAAA;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA","names":["UnavailabilityError","ExpoFaceDetector","FaceDetectorMode","FaceDetectorLandmarks","FaceDetectorClassifications","detectFacesAsync","uri","options","detectFaces"],"sourceRoot":"","sources":["../src/FaceDetector.ts"],"sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoFaceDetector from './ExpoFaceDetector';\n\n// @docsMissing\nexport type Point = { x: number; y: number };\n\n// @needsAudit\nexport type FaceFeature = {\n  /**\n   * An object containing face bounds.\n   */\n  bounds: FaceFeatureBounds;\n  /**\n   * Probability that the face is smiling. Returned only if detection classifications property is\n   * set to `FaceDetectorClassifications.all`.\n   */\n  smilingProbability?: number;\n  /**\n   * Position of the left ear in image coordinates. Returned only if detection classifications\n   * property is set to `FaceDetectorLandmarks.all`.\n   */\n  leftEarPosition?: Point;\n  /**\n   * Position of the right ear in image coordinates. Returned only if detection classifications\n   * property is set to `FaceDetectorLandmarks.all`.\n   */\n  rightEarPosition?: Point;\n  /**\n   * Position of the left eye in image coordinates. Returned only if detection classifications\n   * property is set to `FaceDetectorLandmarks.all`.\n   */\n  leftEyePosition?: Point;\n  /**\n   * Probability that the left eye is open. Returned only if detection classifications property is\n   * set to `FaceDetectorClassifications.all`.\n   */\n  leftEyeOpenProbability?: number;\n  /**\n   * Position of the right eye in image coordinates. Returned only if detection classifications\n   * property is set to `FaceDetectorLandmarks.all`.\n   */\n  rightEyePosition?: Point;\n  /**\n   * Probability that the right eye is open. Returned only if detection classifications property is\n   * set to `FaceDetectorClassifications.all`.\n   */\n  rightEyeOpenProbability?: number;\n  /**\n   * Position of the left cheek in image coordinates. Returned only if detection classifications\n   * property is set to `FaceDetectorLandmarks.all`.\n   */\n  leftCheekPosition?: Point;\n  /**\n   * Position of the right cheek in image coordinates. Returned only if detection classifications\n   * property is set to `FaceDetectorLandmarks.all`.\n   */\n  rightCheekPosition?: Point;\n  /**\n   * Position of the left edge of the mouth in image coordinates. Returned only if detection\n   * classifications property is set to `FaceDetectorLandmarks.all`.\n   */\n  leftMouthPosition?: Point;\n  /**\n   * Position of the center of the mouth in image coordinates. Returned only if detection\n   * classifications property is set to `FaceDetectorLandmarks.all`.\n   */\n  mouthPosition?: Point;\n  /**\n   * Position of the right edge of the mouth in image coordinates. Returned only if detection\n   * classifications property is set to `FaceDetectorLandmarks.all`.\n   */\n  rightMouthPosition?: Point;\n  /**\n   * Position of the bottom edge of the mouth in image coordinates. Returned only if detection\n   * classifications property is set to `FaceDetectorLandmarks.all`.\n   */\n  bottomMouthPosition?: Point;\n  /**\n   * Position of the nose base in image coordinates. Returned only if detection classifications\n   * property is set to `FaceDetectorLandmarks.all`.\n   */\n  noseBasePosition?: Point;\n  /**\n   * Yaw angle of the face (heading, turning head left or right).\n   */\n  yawAngle?: number;\n  /**\n   * Roll angle of the face (bank).\n   */\n  rollAngle?: number;\n  /**\n   * A face identifier (used for tracking, if the same face appears on consecutive frames it will\n   * have the same `faceID`).\n   */\n  faceID?: number;\n};\n\n// @needsAudit\nexport type FaceFeatureBounds = {\n  /**\n   * Size of the square containing the face in image coordinates,\n   */\n  size: {\n    width: number;\n    height: number;\n  };\n  /**\n   * Position of the top left corner of a square containing the face in image coordinates,\n   */\n  origin: Point;\n};\n\n// @docsMissing\nexport enum FaceDetectorMode {\n  fast = 1,\n  accurate = 2,\n}\n\n// @docsMissing\nexport enum FaceDetectorLandmarks {\n  all = 1,\n  none = 2,\n}\n\n// @docsMissing\nexport enum FaceDetectorClassifications {\n  all = 1,\n  none = 2,\n}\n\n// @needsAudit\nexport type Image = {\n  /**\n   * URI of the image.\n   */\n  uri: string;\n  /**\n   * Width of the image in pixels.\n   */\n  width: number;\n  /**\n   * Height of the image in pixels.\n   */\n  height: number;\n  /**\n   * Orientation of the image (value conforms to the EXIF orientation tag standard).\n   */\n  orientation: number;\n};\n\n// @needsAudit\n/**\n * In order to configure detector's behavior modules pass a settings object which is then\n * interpreted by this module.\n */\nexport type DetectionOptions = {\n  /**\n   * Whether to detect faces in fast or accurate mode. Use `FaceDetector.FaceDetectorMode.{fast, accurate}`.\n   */\n  mode?: FaceDetectorMode;\n  /**\n   * Whether to detect and return landmarks positions on the face (ears, eyes, mouth, cheeks, nose).\n   * Use `FaceDetector.FaceDetectorLandmarks.{all, none}`.\n   */\n  detectLandmarks?: FaceDetectorLandmarks;\n  /**\n   * Whether to run additional classifications on detected faces (smiling probability, open eye\n   * probabilities). Use `FaceDetector.FaceDetectorClassifications.{all, none}`.\n   */\n  runClassifications?: FaceDetectorClassifications;\n  /**\n   * Minimal interval in milliseconds between two face detection events being submitted to JS.\n   * Use, when you expect lots of faces for long time and are afraid of JS Bridge being overloaded.\n   * @default `0`\n   */\n  minDetectionInterval?: number;\n  /**\n   * Flag to enable tracking of faces between frames. If true, each face will be returned with\n   * `faceID` attribute which should be consistent across frames.\n   * @default `false`\n   */\n  tracking?: boolean;\n};\n\n// @needsAudit\nexport type DetectionResult = {\n  /**\n   * Array of faces objects.\n   */\n  faces: FaceFeature[];\n  // @docsMissing\n  image: Image;\n};\n\n// @needsAudit\n/**\n * Detect faces on a picture.\n * @param uri `file://` URI to the image.\n * @param options A map of detection options.\n * @return Returns a Promise which fulfils with [`DetectionResult`](#detectionresult) object.\n */\nexport async function detectFacesAsync(\n  uri: string,\n  options: DetectionOptions = {}\n): Promise<DetectionResult> {\n  if (!ExpoFaceDetector.detectFaces) {\n    throw new UnavailabilityError('expo-face-detector', 'detectFaces');\n  }\n  return await ExpoFaceDetector.detectFaces({ ...options, uri });\n}\n"]},"metadata":{},"sourceType":"module"}